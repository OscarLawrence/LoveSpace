"""Core data models for validation system - 150 LOC max"""

from dataclasses import dataclass
from enum import Enum
from typing import Any


class ValidationStatus(Enum):
    """Validation result status"""

    PASSED = "passed"
    FAILED = "failed"
    WARNING = "warning"
    PENDING = "pending"


class HaltReason(Enum):
    """Reasons for execution halt"""

    LOGICAL_CONTRADICTION = "logical_contradiction"
    MISSING_CONTEXT = "missing_context"
    TOKEN_LIMIT = "token_limit"
    CRITICAL_ERROR = "critical_error"
    USER_REQUEST = "user_request"


@dataclass
class ValidationResult:
    """Result of a validation check"""

    status: ValidationStatus
    message: str
    score: float = 0.0
    details: dict[str, Any] | None = None
    recommendations: list[str] | None = None

    def __post_init__(self):
        if self.details is None:
            self.details = {}
        if self.recommendations is None:
            self.recommendations = []


@dataclass
class ContradictionReport:
    """Report of logical contradictions found"""

    statement_a: str
    statement_b: str
    contradiction_type: str
    confidence: float
    context: str
    line_numbers: list[int] | None = None

    def __post_init__(self):
        if self.line_numbers is None:
            self.line_numbers = []


@dataclass
class ContextCompleteness:
    """Context completeness assessment"""

    required_elements: set[str]
    present_elements: set[str]
    missing_elements: set[str]
    completeness_score: float
    critical_missing: list[str] | None = None

    def __post_init__(self):
        if self.critical_missing is None:
            self.critical_missing = []
        self.missing_elements = self.required_elements - self.present_elements


@dataclass
class TokenAnalysis:
    """Token usage analysis"""

    total_tokens: int
    estimated_tokens: int
    efficiency_score: float
    optimization_suggestions: list[str]
    cost_estimate: float = 0.0

    def __post_init__(self):
        if not self.optimization_suggestions:
            self.optimization_suggestions = []


@dataclass
class HaltEvent:
    """Execution halt event"""

    reason: HaltReason
    message: str
    timestamp: str
    context: dict[str, Any]
    recoverable: bool = True

    def __post_init__(self):
        if self.context is None:
            self.context = {}


@dataclass
class CoherenceScore:
    """Logical coherence scoring"""

    overall_score: float
    contradiction_penalty: float
    completeness_bonus: float
    pattern_consistency: float
    confidence_level: float
    breakdown: dict[str, float] | None = None

    def __post_init__(self):
        if self.breakdown is None:
            self.breakdown = {}


@dataclass
class PatternMatch:
    """Pattern matching result"""

    pattern_id: str
    match_confidence: float
    matched_text: str
    context_span: str
    metadata: dict[str, Any] | None = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class ValidationSession:
    """Validation session state"""

    session_id: str
    start_time: str
    current_context: str
    validation_results: list[ValidationResult]
    halt_events: list[HaltEvent]
    token_usage: TokenAnalysis
    active: bool = True

    def __post_init__(self):
        if not self.validation_results:
            self.validation_results = []
        if not self.halt_events:
            self.halt_events = []


class ValidationConfig:
    """Configuration for validation system"""

    def __init__(self):
        self.max_token_limit = 100000
        self.halt_on_contradiction = True
        self.completeness_threshold = 0.7
        self.confidence_threshold = 0.8
        self.enable_pattern_matching = True
        self.auto_optimize_tokens = True
        self.log_validation_events = True


# Validation registry for tracking active validations
validation_registry: dict[str, ValidationSession] = {}


def create_validation_session(session_id: str, context: str) -> ValidationSession:
    """Create new validation session"""
    from datetime import datetime

    session = ValidationSession(
        session_id=session_id,
        start_time=datetime.now().isoformat(),
        current_context=context,
        validation_results=[],
        halt_events=[],
        token_usage=TokenAnalysis(0, 0, 1.0, []),
    )

    validation_registry[session_id] = session
    return session


def get_validation_session(session_id: str) -> ValidationSession | None:
    """Get existing validation session"""
    return validation_registry.get(session_id)


def close_validation_session(session_id: str) -> None:
    """Close and remove validation session"""
    if session_id in validation_registry:
        validation_registry[session_id].active = False
        del validation_registry[session_id]
